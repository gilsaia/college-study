### 2.1

long long 类型是在C++11中新规定的

类型unsigned int 可以被缩写为unsigned 

字符型被分为 char,unsigned char,signed char,尽管字符型有三种，但字符的表现形式只有两种：带符号的和无符号的
char类型具体表现为哪一种要由编译器来决定

在算术表达式中尽量不使用char和bool，因为在一些机器上char是有符类型的而另一些是无符类型的，如果必须使用明确指出是signed char还是unsigned char

浮点数运算用double，因为float与double计算代价相差无几而float可能会有精度不够的情况，long double一般是没有必要使用的

##### 练习2.1

存储数据所用的位数不同;无符号类型全部空间用来存储数据而有符类型一般正值和负值是平衡的;两者精度不同

赋给无符号类型一个超出它表示范围的值时，结果是 **初始值对无符号类型表示数值总数取模后的余数**。

赋给带符号类型一个超出它表示范围的值时，结果是 **未定义的**。

当一个算术表达式中既有无符号数又有int值时，int值会转换为无符号数，转换过程和把int直接赋给无符号变量一样

##### 练习2.3

32 4294967294 32 -32 0 0

字面值常量八进制以0开头而十六进制以0x或0X开头

十进制字面值是带符号数，八进制和十六进制字面值是带符号或无符号数

十进制字面值中的负号只是对字面值取负值而已

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e后缀表示

当两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体，当一行太长写在一起不合适时可拆开写
例：
```
std::cout<<"a really,really long string literal "
"that spans two lines"<<std::endl
```
转义序列中可用`\123`表示八进制的123对应字符集中的符号而`\x123`表示十六进制的符号

注意： **八进制数字不可超过三个而十六进制数字由其后的所有数字构成**

字面值后缀决定的是字面值的最小类型会按照实际情况有不同调整

##### 练习2.5

(a) char,wchar_t,char[],wchar_t[]

(b) int,unsigned,long,unsigned long,int,int

(c) double,float,long double

(d) int,unsigned,double,double

##### 练习2.6

有，一组为十进制9和7，一组为八进制9和7

##### 练习2.7

(a) char[] 
(b) long double
(c) float
(d) long double

##### 练习2.8

```
std::cout<<"2\115\n";

std::cout<<"2\t\115\n";
```

### 2.2

初始化变量的值可以是任意复杂的表达式，当定义了多个变量，对象的名字随着定义就可马上使用
例： `double price=109.99,discount=price*0.16 //正确用法`

初始化不是赋值，初始化是创建变量时赋予其一个初始值，而赋值是将对象的当前值擦除用一个新值代替

当使用列表初始化时，若初始值存在丢失信息的风险，则编译器将报错

定义于任何函数体之外的变量被初始化为0，而 **定义于函数体内部的内置类型变量将不被初始化**，
若类的对象没有显示初始化，其值由类确定。

##### 练习2.9

(a) 调用语句中不能直接加定义语句，或可改为
```
int input_value;
std::cin>>input_value;
```
(b) 列表初始化且会丢失信息，编译器会报错，可改为`int i=(3.14);`
(c) 连续定义方法不对，可改为`double wage=9999.99,salary=wage;`
(d) 无问题但会丢失信息

##### 练习2.10

global_str为空串
global_int为0
local_int为定义
local_str为空串

任何包含显式初始化的声明即为定义，extern声明的变量可以初始化但也就抵消了extern的作用
**函数体内部初始化一个由extern标记的变量，将引发错误**

##### 练习2.11

(a) 定义
(b) 定义
(c) 声明

标识符对大小写敏感但对长度无要求，自定义标识符不能出现 **连续两个下划线**或 **以下划线紧接大写字母开头**，此外，**函数体外**，的标识符不能 **以下划线开头**

##### 练习2.12

(a)非法，double不能作变量名
(b)在函数体内合法，但个人不建议使用
(c)合法
(d)合法
(e)合法

名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束

##### 练习2.13

j=100;

##### 练习2.14

100 25

### 2.3

不能出现引用的引用

除了之后的两种例外，引用的类型要与绑定的对象严格匹配，并且不能与字面值或表达式的计算结果绑定在一起

##### 练习2.15

(a) 合法但损失信息
(b) 不合法，引用不能绑定字面值
(c) 合法
(d) 不合法，未初始化

##### 练习2.16

(a) 合法，d=3.14159
(b) 合法，d=0
(c) 合法，i=0
(d) 合法，i=0

##### 练习2.17

10 10

生成空指针的方法
```
int *p1=nullptr;
int *p2=0;
//须include cstdlib
int *p3=NULL;//NULL其值为0
```

指针只要拥有合法值就能用于条件表达式中，任何非0指针条件值都为true

##### 练习2.19

指针是一个新的复合类型，存放的是地址，只是地址指向的是某些变量，而引用只是给某些变量所起的别名，多了一种称呼及方便，并没有实际的内存空间

##### 练习2.20

将i的值平方

##### 练习2.21

(a) 非法，double型指针不能指向int型变量
(b) 非法，指针初始化的值不是地址
(c) 合法

##### 练习2.22

```
if(p)//如果p不是空指针则···
if(*p)//如果p所指的变量内容不是0则···
```

##### 练习2.23

不能，只能知道是否非空，非空时指向值一定存在但不一定有意义

##### 练习2.24

p为void *可指向任何类型而lp为long *只可指向long类型

变量的定义包括一个基本数据类型和一组声明符，* &等类型修饰符是声明符的一部分

引用不是对象，所以不存在指向引用的指针，但可以有对指针的引用
例：
```
int i=42;
int *p;
int *&r=p;
r=&i;
*r=0;
```
理解r的类型最简单的方法是从右向左看，离变量名最近的符号对变量的类型有最直接的影响

##### 练习2.25

(a) ip为int指针，i为int对象，r为i的引用
(b) i为int对象，ip为int型空指针
(c) ip为int指针，ip2为int对象