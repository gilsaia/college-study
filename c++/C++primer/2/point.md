### 2.1

long long 类型是在C++11中新规定的

类型unsigned int 可以被缩写为unsigned 

字符型被分为 char,unsigned char,signed char,尽管字符型有三种，但字符的表现形式只有两种：带符号的和无符号的
char类型具体表现为哪一种要由编译器来决定

在算术表达式中尽量不使用char和bool，因为在一些机器上char是有符类型的而另一些是无符类型的，如果必须使用明确指出是signed char还是unsigned char

浮点数运算用double，因为float与double计算代价相差无几而float可能会有精度不够的情况，long double一般是没有必要使用的

##### 练习2.1

存储数据所用的位数不同;无符号类型全部空间用来存储数据而有符类型一般正值和负值是平衡的;两者精度不同

赋给无符号类型一个超出它表示范围的值时，结果是 **初始值对无符号类型表示数值总数取模后的余数**。

赋给带符号类型一个超出它表示范围的值时，结果是 **未定义的**。

当一个算术表达式中既有无符号数又有int值时，int值会转换为无符号数，转换过程和把int直接赋给无符号变量一样

##### 练习2.3

32 4294967294 32 -32 0 0

字面值常量八进制以0开头而十六进制以0x或0X开头

十进制字面值是带符号数，八进制和十六进制字面值是带符号或无符号数

十进制字面值中的负号只是对字面值取负值而已

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e后缀表示

当两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体，当一行太长写在一起不合适时可拆开写
例：
```
std::cout<<"a really,really long string literal "
"that spans two lines"<<std::endl
```
转义序列中可用`\123`表示八进制的123对应字符集中的符号而`\x123`表示十六进制的符号

注意： **八进制数字不可超过三个而十六进制数字由其后的所有数字构成**

字面值后缀决定的是字面值的最小类型会按照实际情况有不同调整

##### 练习2.5

(a) char,wchar_t,char[],wchar_t[]

(b) int,unsigned,long,unsigned long,int,int

(c) double,float,long double

(d) int,unsigned,double,double

##### 练习2.6

有，一组为十进制9和7，一组为八进制9和7

##### 练习2.7

(a) char[] 
(b) long double
(c) float
(d) long double

##### 练习2.8

```
std::cout<<"2\115\n";

std::cout<<"2\t\115\n";
```

### 2.2

初始化变量的值可以是任意复杂的表达式，当定义了多个变量，对象的名字随着定义就可马上使用
例： `double price=109.99,discount=price*0.16 //正确用法`

初始化不是赋值，初始化是创建变量时赋予其一个初始值，而赋值是将对象的当前值擦除用一个新值代替

当使用列表初始化时，若初始值存在丢失信息的风险，则编译器将报错

定义于任何函数体之外的变量被初始化为0，而 **定义于函数体内部的内置类型变量将不被初始化**，
若类的对象没有显示初始化，其值由类确定。

##### 练习2.9

(a) 调用语句中不能直接加定义语句，或可改为
```
int input_value;
std::cin>>input_value;
```
(b) 列表初始化且会丢失信息，编译器会报错，可改为`int i=(3.14);`
(c) 连续定义方法不对，可改为`double wage=9999.99,salary=wage;`
(d) 无问题但会丢失信息

##### 练习2.10

global_str为空串
global_int为0
local_int为定义
local_str为空串