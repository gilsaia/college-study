### 2.1

long long 类型是在C++11中新规定的

类型unsigned int 可以被缩写为unsigned 

字符型被分为 char,unsigned char,signed char,尽管字符型有三种，但字符的表现形式只有两种：带符号的和无符号的
char类型具体表现为哪一种要由编译器来决定

在算术表达式中尽量不使用char和bool，因为在一些机器上char是有符类型的而另一些是无符类型的，如果必须使用明确指出是signed char还是unsigned char

浮点数运算用double，因为float与double计算代价相差无几而float可能会有精度不够的情况，long double一般是没有必要使用的

##### 练习2.1

存储数据所用的位数不同;无符号类型全部空间用来存储数据而有符类型一般正值和负值是平衡的;两者精度不同

赋给无符号类型一个超出它表示范围的值时，结果是 **初始值对无符号类型表示数值总数取模后的余数**。

赋给带符号类型一个超出它表示范围的值时，结果是 **未定义的**。

当一个算术表达式中既有无符号数又有int值时，int值会转换为无符号数，转换过程和把int直接赋给无符号变量一样

##### 练习2.3

32 4294967294 32 -32 0 0

字面值常量八进制以0开头而十六进制以0x或0X开头

十进制字面值是带符号数，八进制和十六进制字面值是带符号或无符号数

十进制字面值中的负号只是对字面值取负值而已

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e后缀表示

当两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体，当一行太长写在一起不合适时可拆开写
例：
```
std::cout<<"a really,really long string literal "
"that spans two lines"<<std::endl
```
转义序列中可用`\123`表示八进制的123对应字符集中的符号而`\x123`表示十六进制的符号

注意： **八进制数字不可超过三个而十六进制数字由其后的所有数字构成**

字面值后缀决定的是字面值的最小类型会按照实际情况有不同调整

##### 练习2.5

(a) char,wchar_t,char[],wchar_t[]

(b) int,unsigned,long,unsigned long,int,int

(c) double,float,long double

(d) int,unsigned,double,double

##### 练习2.6

有，一组为十进制9和7，一组为八进制9和7

##### 练习2.7

(a) char[] 
(b) long double
(c) float
(d) long double

##### 练习2.8

```
std::cout<<"2\115\n";

std::cout<<"2\t\115\n";
```

### 2.2

初始化变量的值可以是任意复杂的表达式，当定义了多个变量，对象的名字随着定义就可马上使用
例： `double price=109.99,discount=price*0.16 //正确用法`

初始化不是赋值，初始化是创建变量时赋予其一个初始值，而赋值是将对象的当前值擦除用一个新值代替

当使用列表初始化时，若初始值存在丢失信息的风险，则编译器将报错

定义于任何函数体之外的变量被初始化为0，而 **定义于函数体内部的内置类型变量将不被初始化**，
若类的对象没有显示初始化，其值由类确定。

##### 练习2.9

(a) 调用语句中不能直接加定义语句，或可改为
```
int input_value;
std::cin>>input_value;
```
(b) 列表初始化且会丢失信息，编译器会报错，可改为`int i=(3.14);`
(c) 连续定义方法不对，可改为`double wage=9999.99,salary=wage;`
(d) 无问题但会丢失信息

##### 练习2.10

global_str为空串
global_int为0
local_int为定义
local_str为空串

任何包含显式初始化的声明即为定义，extern声明的变量可以初始化但也就抵消了extern的作用
**函数体内部初始化一个由extern标记的变量，将引发错误**

##### 练习2.11

(a) 定义
(b) 定义
(c) 声明

标识符对大小写敏感但对长度无要求，自定义标识符不能出现 **连续两个下划线**或 **以下划线紧接大写字母开头**，此外，**函数体外**，的标识符不能 **以下划线开头**

##### 练习2.12

(a)非法，double不能作变量名
(b)在函数体内合法，但个人不建议使用
(c)合法
(d)合法
(e)合法

名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束

##### 练习2.13

j=100;

##### 练习2.14

100 25

### 2.3

不能出现引用的引用

除了之后的两种例外，引用的类型要与绑定的对象严格匹配，并且不能与字面值或表达式的计算结果绑定在一起

##### 练习2.15

(a) 合法但损失信息
(b) 不合法，引用不能绑定字面值
(c) 合法
(d) 不合法，未初始化

##### 练习2.16

(a) 合法，d=3.14159
(b) 合法，d=0
(c) 合法，i=0
(d) 合法，i=0

##### 练习2.17

10 10

生成空指针的方法
```
int *p1=nullptr;
int *p2=0;
//须include cstdlib
int *p3=NULL;//NULL其值为0
```

指针只要拥有合法值就能用于条件表达式中，任何非0指针条件值都为true

##### 练习2.19

指针是一个新的复合类型，存放的是地址，只是地址指向的是某些变量，而引用只是给某些变量所起的别名，多了一种称呼及方便，并没有实际的内存空间

##### 练习2.20

将i的值平方

##### 练习2.21

(a) 非法，double型指针不能指向int型变量
(b) 非法，指针初始化的值不是地址
(c) 合法

##### 练习2.22

```
if(p)//如果p不是空指针则···
if(*p)//如果p所指的变量内容不是0则···
```

##### 练习2.23

不能，只能知道是否非空，非空时指向值一定存在但不一定有意义

##### 练习2.24

p为void *可指向任何类型而lp为long *只可指向long类型

变量的定义包括一个基本数据类型和一组声明符，* &等类型修饰符是声明符的一部分

引用不是对象，所以不存在指向引用的指针，但可以有对指针的引用
例：
```
int i=42;
int *p;
int *&r=p;
r=&i;
*r=0;
```
理解r的类型最简单的方法是从右向左看，离变量名最近的符号对变量的类型有最直接的影响

##### 练习2.25

(a) ip为int指针，i为int对象，r为i的引用
(b) i为int对象，ip为int型空指针
(c) ip为int指针，ip2为int对象

### 2.4

默认情况下，const对象仅在文件内有效,在多个文件出现同名的const变量时，等同于在不同文件分别定义了独立的变量

想在多文件之间共享一个const对象，只要对每个变量的声明或定义部分都加extern声明即可

##### 练习2.26

(a) 不合法，const对象未初始化
(b) 合法
(c) 合法
(d) 不合法，试图改变const对象的值

对const的引用简称常量引用，不能让一个非常量引用指向一个常量对象

初始化常量引用时允许用任意表达式作为初始值，只要表达式结果能转换成引用类型即可

在这种情况下绑定的是一个临时量对象如`double dval=3.14;const int &ri=dval;`实际上是如下形式
`const int temp=dval;const int &ri=temp;`

##### 练习2.27

(a) 非法，非常量引用初始化不能用表达式
(b) 合法，常量指针，即其所指的变量固定但变量本身仍可变
(C) 合法，常量引用初始化可用表达式
(d) 合法，指向常量的常量指针
(e) 合法，指向常量的指针
(f) 不合法，引用不是对象不能将引用本身设为常量
(g) 合法

##### 练习2.28

(a) int型对象i,指向int型对象的常量指针cp
(b) 指向int型对象的指针p1，指向int型对象的常量指针p2
(c) int型常量ic，常量引用r(非法，未初始化)
(d) 指向int型常量的常量指针p3(非法，未初始化)
(e) 指向int型常量的指针p(非法，未初始化)

##### 练习2.29

(a) 合法
(b) 非法，p3有底层const而p1没有
(c) 非法，同理
(d) 非法，常量指针不允许改变
(e) 非法，常量指针不允许改变
(f) 非法，常量对象不允许改变

执行对象的拷贝操作时，顶层const几乎没什么影响，而底层const的限制不能忽视

##### 练习2.30

v2顶层const,p2底层const,p3底层const和顶层const皆有,r2底层const

##### 练习2.31
```
r1=v2;//合法，仅仅改变复制且皆无底层const
p1=p2;p2=p1;//前半句非法后半句合法，p2有底层const属性不能赋给p1
p1=p3;p2=p3;//前半句非法，与上面同理，p3的顶层const并无影响
```

将变量声明为constexpr类型以便由编译器验证变量值是否为一个常量表达式，声明为constexpr的变量一定是常量，必须用常量表达式初始化，否则会报错，若是函数则应为constexpr函数

一般情况下，函数体内定义的变量一般来说并非存放于固定地址中，因此constexpr指针不能指向这样的变量(后文有例外情况)

如果指针加了constexpr说明，那它仅对指针有效，与所指对象无关(即常量指针)

##### 练习2.32

非法，若null不是系统命名变量，则将`*p=null`改为`*p=&null`即可，若为系统变量，则整体改名即可

类型别名的两种方法，第一种为typrdef，与声明语句类似，只不过定义的不是变量而是类型别名，允许包含类型修饰
例：
```
typedef double wages;//wages是double的别名
typrdef wages base,*p;//base是wages的别名，p是wages *的别名
```
第二种是别名声明
例：
```
using SI=double;//SI是double的别名
```

当用类型别名指代复合类型或常量要时刻注意
例如
```
typrdef char*pstring;
const pstring cstr=0;//这里cstr是常量指针而非指向常量的指针，这个const为顶层const
//当用pstring代指时基本数据类型就是指针，这时加const使指针为常量指针
const char * cstr=0;//!!!注意这个和上面有本质的不同！基本类型是char，*只作为声明符！此时cstr为指向常量的指针
```

auto变量必须有初始值

一条语句只有一个基本类型，所以语句中所有变量的初始基本数据类型都必须一样

auto一般会忽略顶层const,而底层const会被保留，对引用实际作用的是其引用的对象

**设置为auto的引用时，顶层常量属性仍会保留**

**对常量取地址是一种底层const**


如果需要auto类型是一个顶层const，需要明确指出
例：
```
int i=0;
const int ci=i,&cr=ci;
auto b=ci;//b是一个整数
auto c=cr;//同上
auto d=&i;//d是一个整型指针
auto e=&ci;//e是一个指向整数常量的指针
const auto f=ci;//f是const int
auto &n=i,*p2=&ci;//错误，i类型是int而&ci类型是const int
```

##### 练习2.33

d，e为指针无法赋值，g为整型常量引用，无法更改值

##### 练习2.35

i为int型常量，j为int型变量，k为int型常量引用，p为指向常量int的指针，j2为int型常量，k2与k相同

decltype类型说明符返回操作数的数据类型，此过程编译器只分析表达式并得到它的类型并不实际计算表达式的值

decltype会保留 **顶层const和引用**

引用从来都作为其所指对象的同义词出现，只有在decltype处例外

```
int i=42,*p=&i,&r=i;
decltype(r+0) b;//r为引用类型，但r+0结果为int类型
decltype(*p) c;//错误，解引用指针会得到int&
decltype((i)) d;//错误，d为int&，须初始化
```
**当变量多加一层括号时会被当做特殊的表达式使decltype得到引用类型**

##### 练习2.36

c int
d int&

##### 练习2.37

c int
d int&

##### 练习2.38

最主要的区别两者对引用和顶层const的处理不同

类体右侧表示结束的花括号必须写一个分号，这是因为其后可以紧跟变量名以示对该类型对象的定义

可以为数据成员提供一个类内初始值，方法是放在花括号里或等号右侧

##### 练习2.39

编译器报错，无法通过编译

头文件通常包含只能被定义一次的实体

要注意对头文件的处理以避免重复包含问题

```
#ifndef SALES_DATA_H//当变量未定义时为真
#define  SALES_DATA_H//把一个名字设定为预处理变量
#endif //上面#ifndef指令若为假跳至此处
```
通常基于头文件类的名字构建保护符的名字以确保其唯一性，为避免与其他实体发生名字冲突一般把预处理变量全部大写