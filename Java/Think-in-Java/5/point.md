### 5.2

重载依旧按照参数列表来分开，基本类型可以自动提升但不能自动窄化转换，除非强制变换类型否则会报错

### 5.3

默认构造函数仍然保持如果写入其他构造函数则不默认生成

### 5.4

当在方法内部调用同一个类的另一个方法，可以不必使用this

在一个构造器内调用另一个构造器时可用this调用但只可用一次且 **必须将构造器调用放在最起始处**

除构造器外，编译器禁止在其他任何地方调用构造器

### 5.5

Java中并没有类似析构函数的设计，垃圾回收机制与析构函数并不相同，在某些特殊的调用本地方法(例如C的malloc（）方法)，需要在方法中创建finalize()方法里调用本地方法(按照上例为C的free()方法)

终结函数可以用来验证对象的终结条件

一般来说总要调用基类的finalize()，所以在写的最后一般要加一句`super.finalize();`

### 5.6

方法中若有值为初始化会报错，类中数据成员若为基本类型则会有一个初始值，定义对象引用若不初始化则会有一个特殊值null

想为某个变量赋初值可直接在定义的地方赋值(**注意C++不能这样！**)

可以调用方法，包括无参或含参但是若含参一定要是初始化过的

### 5.7

变量初始化顺序在构造器初始化之前

静态对象只有在用到的时候才会被初始化，初始化顺序是先静态对象，而后非静态对象，静态对象只会被初始化一次

Java允许将多个静态初始化动作组织成一个特殊的“静态子句”，即类似
```Java
Class cups
{
    static cup cup1;
    static cup cup2;
    static
    {
        cup1=new cup(1);
        cup2=new cup(2);
    }
    //...
}
```
对于非静态成员，也有类似的被称作实例初始化的语法
```Java
class Mugs
{
    Mug mug1;
    Mug mug2;
    {
        mug1=new Mug(1);
        mug2=new Mug(2);
    }
    //...
}
```
他们执行在构造器之前，即第一次调用相关类或静态成员时